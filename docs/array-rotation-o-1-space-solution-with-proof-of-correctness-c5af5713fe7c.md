# 数组旋转——O(1)空间解，带有正确性证明

> 原文：<https://medium.datadriveninvestor.com/array-rotation-o-1-space-solution-with-proof-of-correctness-c5af5713fe7c?source=collection_archive---------0----------------------->

# 背景

[提问](https://www.leetfree.com/problems/rotate-array.html)在微软和亚马逊等顶级科技公司，[精选](https://leetcode.com/problems/rotate-array/)在 Leetcode 等面试准备网站，数组轮换是一个简单而有效的问题，可以用来衡量受访者的分析和编码技能。与重视运行时复杂性的流行观念相反，这个问题需要优化空间复杂性。在 O(n)运行时和 O(n)空间中解决这个问题很简单，但是需要一些思考才能得到 O(1)空间的解决方案。这个解决方案，将在稍后用 Python 演示和验证，是非常出色和简洁的。

![](img/8e68fb6099e83171dd5d75e7d7638e8a.png)

Photo by [Helloquence](https://unsplash.com/@helloquence?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

# 问题

## 声明

给定一个数组，将数组向右旋转 *k* 步，其中 *k* 为非负。

## 例子

如果一个数组是*【1，2，3，4，5】**k = 2*，那么答案应该是*【4，5，1，2，3】*。
这里，如果 *k = 3* ，答案应该是:*【3，4，5，1，2】*。

# 平凡解

对于想知道其简单解决方案的读者，您可以简单地创建一个空列表(用 Python)并进行一次迭代。在进行核心算法之前，记得用 *n* 取 *k* 的模，数组的大小。由于旋转数组*【1，2，3，4，5】*六次等同于旋转一次，所以我们使用 *k* 的模数值。

[](https://www.datadriveninvestor.com/2019/03/22/the-seductive-business-logic-of-algorithms/) [## 算法诱人的商业逻辑|数据驱动的投资者

### 某些机器行为总是让我感到惊讶。我对他们从自己的成就中学习的能力感到惊讶…

www.datadriveninvestor.com](https://www.datadriveninvestor.com/2019/03/22/the-seductive-business-logic-of-algorithms/) 

新形成的列表中的第一个元素将是第*k 个*最后一个元素。列表中的第二个元素是第 *(k-1)个*最后一个元素。这样，我们就可以建立一个模式，并对其进行编码。如果你在这里纠结，请在评论里告诉我。

# O(1)解

但是，平凡解占用 *O(n)* 空间。通常情况下，在技术面试设置中，问题的复杂性随着问题的增加而增加。得到 O(1)空间的解比平凡解多一级难度，可以归类为“中等”问题。

## 算法

*   反转数组。
*   反转由第一个 *k 个*元素组成的数组的子数组。
*   反转阵列的其余部分，不包括前面的子阵列。

简单而优雅，不是吗？

# 正确性证明

让我们通过任意取一个元素，通过算法推理来证明它的正确性。让我们在这里使用基于 *0* 的索引。

## **索赔**

旋转后，索引为的*处的值应该在索引为 *(i + k) mod n* 处。*

## 证明

第一步是整个数组的反转。这将使索引为的*的值变为索引为 *(n - 1 - i)的*的值。
根据新索引 *(n - 1 - i)* 的值，元素可以落在第一子数组或第二子数组中。*

*情况 I(第一个子数组)* 如果元素位于第一个子数组中，第二步给出最终位置。
第二步后的位置变成:
=*k-1-(n-1-I)
= k-1-n+1+I
= I+k-n*

由于元素位于第一个子阵中，
*n - 1 - i ≤ k - 1
or，i + k ≥ n
or，i + k - n ≥ 0*

现在，由于值 *i + k - n* 非负，所以等于 *(i + k) mod n* 。

*情况二(第二子数组)* 如果元素位于第二子数组，第三步给出最终位置。
第三步后的位置变成:
*= k+(n-k-1)-(n-1-I-k)
= k+n-k-1-n+1+I+k
= I+k*

由于元素位于第二子阵列中，
n-1-I>k-1
因此，i + k < n

由于值 *i + k* 小于 *n* 且为正(I*I*和 k*k*均为正)， *i + k* 等于 *(i + k) mod n.*

于是，*证明了。*

# Python 解决方案

我们首先创建一个 helper 函数，在给定起始和结束索引的情况下反转一个数组的子数组。使用这个辅助函数，旋转数组很简单。

在这里，值的交换是就地完成的——恒定空间。所以，反转子程序是 O(1)。由于该解有三个相继的逆解，它只占用 O(1)空间。

如此高效、出色和简洁的解决方案，不是吗？