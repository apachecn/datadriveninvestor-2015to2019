# 基于神经草图的移动应用特定框架

> 原文：<https://medium.datadriveninvestor.com/neural-sketch-based-mobile-application-specific-framework-1ab4fe6dd34a?source=collection_archive---------11----------------------->

**简介**
在代码生成中，生成的代码需要基于输入规范中配置的语法和语义。基于神经草图的移动应用框架通过训练学习。通过显示在框架中配置的应用程序来完成训练。框架模型将具有程序规范，即与应用程序相关的类、方法和实体。移动应用框架通过使用在训练中获得的知识来呈现应用。该应用将具有基于实体和输入配置的应用编程接口调用、方法和数据类型。
基于神经草图的移动应用框架混合了用于显示和呈现本地、混合和基于网络的移动应用的神经和组合方法。这可以用于基于 iOS、Android 和 Windows 操作系统的设备以及设备支持的不同编程语言 SDK。
监督学习是用于训练移动应用框架的方法。训练输入具有基于视图、实体和动作配置的一组应用。应用程序配置提供的元数据有助于框架了解应用程序的语义。该应用程序具有数据类型、方法、控制流、异常和基于类型的实体。
模式由基于神经草图的框架识别，这有助于渲染和显示应用程序。应用程序需要满足配置文件中指定的约束。神经草图框架是基于神经学习和组合搜索的混合。框架中的源代码能够创建基于树的语法模型和草图。易用性

[](https://www.datadriveninvestor.com/2019/02/18/the-challenge-of-forex-trading-for-machine-learning/) [## 机器学习的外汇交易挑战|数据驱动的投资者

### 机器学习是人工智能的一个分支，之前占据了很多头条。人们是…

www.datadriveninvestor.com](https://www.datadriveninvestor.com/2019/02/18/the-challenge-of-forex-trading-for-machine-learning/) 

**神经草图—应用框架**

一个草图与一个类、实体和方法相关。这些方法有参数、返回值和控制流。架构方法基于元数据驱动的架构模式。元数据使用对象存储库模式进行存储和建模。该代码读取元数据，并呈现采用基于微服务的架构的移动应用。该体系结构包括服务层、服务客户端(移动)、持久层、数据访问层和数据库层。这些层使用语言 sdk 和特定于平台的模式和实践来实现。在不同层的输入中配置元数据属性。该应用程序可通过事件、委托、模板、服务和类进行配置和扩展。框架中的代码使用元数据来处理语言 sdk 和平台中的不同层。还配置了帮助文档，它用于应用程序呈现和显示。用户界面可能很复杂，需要布局和不同 UI 控件的额外配置。复杂的业务逻辑将通过定制的模块和类传递。该框架具有处理升级、版本和维护相关功能的能力。
neural sketch 方法基于最新技术，可以通过更改不同层中的应用框架代码堆栈来升级到任何新的技术堆栈。数据库层保存数据。它还处理当前状态。未来的计划状态修改可以由数据库层处理。持久层具有存储和检索来自各种数据源的数据的特性。数据的检索是通过使用不同的适配器完成的。业务逻辑和规则层处理跨业务实体和实体组的复杂变化。服务层处理更新并管理实体组。用户界面层具有与属性和实体的定制、可配置性、可扩展性相关的特征。
不同的组织使用元数据驱动的方法来创建基于移动应用框架的产品。(如甲骨文)。元数据用于通过动态模式和表示层的生成来创建应用程序。其他层在输入配置文件中建模。建模基于基于通用属性的实体模式。
应用框架有助于软件工程生命周期中的升级、定制、维护和其他挑战。提供用户界面用于处理定制。这些定制不需要任何代码更改。定制模块可以被编码，其可以由应用框架加载。
应用程序的用户界面通常简单易用。基于用户的位置和设置，应用程序将以不同的语言、格式和组织/布局呈现。应用程序将支持全球化，包括国际化和本地化。该应用程序将有快速和灵活的搜索和报告。协作和数据共享将是应用程序功能的一部分。该应用程序将支持与系统内外不同的非产品用户共享数据。

**应用架构**

应用程序架构将能够通过使用商业软件包和软件进行扩展。并且只使用所需的功能。安全性和许可需求将由应用程序架构来处理。该体系结构处理诸如插入、编辑和删除等修改的审计。该应用程序将为不同的用户角色和组提供可配置的、多层的、实体上下文敏感的、对数据和操作的安全访问。
应用程序配置将提供定制平台某些方面的能力，如屏幕、数据字段、工作流等。该应用程序将具有与管理元数据和程序更新相关的开发相关配置。
提供示例配置，其中包含系统中使用的表单、表单字段、视图和实体。
*<？xml 版本="1.0 "编码="UTF-8 "？>
< app >
<视图>
<名称>用户</姓名>
<视图编号>1</视图编号>
<视图字段>
<视图字段>用户 id</视图字段>
<*

应用程序将拥有用户视图。用户视图将有用户 Id，用户名和密码的视图字段。
*<表单>
<姓名>用户</姓名>
<表单编号>1</表单编号>
<表单字段>
<表单字段>用户名</表单字段>
<表单字段>密码</表单字段*

用户视图的表单配置将包含用户名和密码表单字段。

*<更新>
<姓名>用户</姓名>
<表单编号>1</表单编号>
<表单字段>用户 id</表单字段>
<搜索表单字段>用户名</搜索表单字段【T125*

更新视图将包含 formno、formIdField、searchFormField 和表单字段 UserName 和 Password。
*<删除>
<姓名>用户</姓名>
<表单编号>1</表单编号>
<表单字段>用户 id</表单字段>
<搜索表单字段>用户名</搜索表单字段<*

删除视图将包含 formno、formIdField、searchFormField 以及用户名和密码等表单字段。
下面的配置显示了 web 服务请求和响应模式。用户服务将具有 getAll、getUser、InsertUser、UpdateUser 和 DeleteUser 方法。

*<？xml 版本="1.0 "编码="UTF-8 "？>
<wsdl:definitions>
<wsdl:types>
<schema>
<import namespace = " http://POJO . telecom . teal . arch corner . org "/>
<element name = " getAll ">
<complex type/>
</element>
<element name = "元素名*

获取所有方法请求和响应的定义如上所示。

*<element name = " getUser ">
<complex type>
<sequence>
<element name = " userName " type = " xsd:string "/>
</sequence>
</complex type>
</element>
<element name = " "*

获取用户方法请求和响应定义如上所示。

*element name = " update user ">
<complex type>
<sequence>*

*<element name = " user properties " type = " xsd:string "/>
</sequence>
</complex type>
</element>
<element name = " update user response ">
<complex type/>
</element>*
update user

*<element name = " insertUser ">
<complex type>
<sequence>
<element name = " user properties " type = " xsd:string "/>
</sequence>
</complex type>
</element>
<element*

insertUser 方法请求和响应定义如上所示。

*<element name = " deleteUser ">
<complex type>
<sequence>
<element name = " user properties " type = " xsd:string "/>
</sequence>
</complex type>
</element><*

deleteUser 方法请求和响应定义如上所示。
用户复杂类型的模式定义如下所示。
*<schema elementFormDefault = " qualified " target namespace = " http://POJO . telecom . teal . arch corner . org " xmlns = " http://www . w3 . org/2001/XML schema ">
<complex type name = " User ">
<sequence>
<element name = " password " nil lable = " true " type = " "*

用户复杂类型元素如上所示。

*<wsdl:message name = " delete user response ">
<wsdl:part element = " impl:delete user response " name = " parameters ">
</wsdl:part>
</wsdl:message>
<wsdl:message name = " getAll request ">
<wsdl:part element = " impl:getAll "*

上面显示了 deleteUser 响应元素。

*<wsdl:message name = " update user response ">
<wsdl:part element = " impl:update user response " name = " parameters ">
</wsdl:part>
</wsdl:message>
<wsdl:message name = " update user request ">
<wsdl:part element = " impl:update user " name = "的*

上面显示了 updateUser 响应元素。

*<wsdl:message name = " insertUser request ">
<wsdl:part element = " impl:insertUser " name = " parameters ">
</wsdl:part>
</wsdl:message>*
insertUser 请求元素如上图所示。

*<wsdl:message name = " deleteUser request ">
<wsdl:part element = " impl:deleteUser " name = " parameters ">
</wsdl:part>
</wsdl:message>*

上面显示了 deleteUser 请求元素。

*<wsdl:message name = " insertuser response ">
<wsdl:part element = " impl:insertuser response " name = " parameters ">
</wsdl:part>
</wsdl:message>*

InsertUser 响应元素如上所示。

*<wsdl:message name = " getUser request ">
<wsdl:part element = " impl:getUser " name = " parameters ">
</wsdl:part>
</wsdl:message>*

getUser 请求元素如上所示。

*<wsdl:message name = " getall response ">
<wsdl:part element = " impl:getall response " name = " parameters ">
</wsdl:part>
</wsdl:message>*

上面显示了所有的响应元素。

*<wsdl:message name = " getuserbyidnresponse ">
<wsdl:part element = " impl:getuserbyidnresponse " name = " parameters ">
</wsdl:part>
</wsdl:message>*

上面显示了 getUserById 响应元素。

*<wsdl:message name = " getuser response ">
<wsdl:part element = " impl:getuser response " name = " parameters ">
</wsdl:part>
</wsdl:message>*

getUser response 元素如上所示。

*<wsdl:portType name = " UserService ">
<wsdl:operation name = " getAll ">
<wsdl:input message = " impl:getAll request " name = " getAll request ">
</wsdl:input>
<wsdl:output message = " impl:getAll response " name = " getAll response "【T159*

用户服务元素如上所示。

*<wsdl:operation name = " getUser ">
<wsdl:input message = " impl:getUser request " name = " getUser request ">
</wsdl:input>
<wsdl:output message = " impl:getUser response ">
</wsdl:output>
</wsdl:operation>*

getUser 操作输入和消息元素如上所示。
*<wsdl:operation name = " update user ">
<wsdl:input message = " impl:updateUser request " name = " updateUser request ">
</wsdl:input>
<wsdl:output message = " impl:updateUser response " name = " updateUser response ">
</wsdl:output>* 

上面显示了 updateUser 操作输入和消息元素。
*<wsdl:operation name = " getUserById ">
<wsdl:input message = " impl:getUserByIdRequest " name = " getUserByIdRequest ">
</wsdl:input><wsdl:output message = " impl:getUserById response " name = " getuserbyidress ">
</wsdl*

getUserById 操作输入和消息元素如上所示。
*<wsdl:operation name = " insertUser ">
<wsdl:input message = " impl:insertUser request " name = " insertUser request ">
</wsdl:input>
<wsdl:output message = " impl:insertUser response " name = " insertUser response ">
</wsdl:output>
</wsdl*

插入用户操作输入和消息元素如上所示。
*<wsdl:operation name = " deleteUser ">
<wsdl:input message = " impl:deleteUser request " name = " deleteUser request ">
</wsdl:input>
<wsdl:output message = " impl:deleteUser response " name = " deleteUser response ">
</wsdl:output>* 

上面显示了 deleteUser 操作输入和消息元素。

**结论**

之后，应用程序配置可以扩展到不同的层，如服务、实体、持久性和数据访问。基于神经草图的移动应用框架可以用于不同的软件应用。

**参考文献**

[1]用于条件程序生成的神经草图学习 V Murali，L Qi，S Chaudhuri，C Jermaine
[2]用于程序生成的神经属性机器 M Amodio，S Chaudhuri，T Reps
[3] Deepcoder:学习编写程序 M Balog，AL Gaunt，M Brockschmidt，S Nowozin