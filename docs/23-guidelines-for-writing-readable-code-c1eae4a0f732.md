# 23 编写可读代码的指南

> 原文：<https://medium.datadriveninvestor.com/23-guidelines-for-writing-readable-code-c1eae4a0f732?source=collection_archive---------8----------------------->

阅读别人的代码可能会很混乱。本应在几分钟内解决的问题可能会持续几个小时。在这篇文章中，我想分享一些关于如何编写更容易理解和维护的代码的建议。

在我们开始之前，请注意这不是一个关于编写“干净代码”的指南。人们倾向于用这个术语来理解不同的东西，一些人喜欢它容易扩展和通用，一些人喜欢抽象实现和提供配置，还有一些人喜欢看到主观上漂亮的代码。本指南关注可读代码，我指的是尽可能高效地向其他程序员传达必要信息的一段代码。

下面是 23 个帮助你写更可读代码的指南，这是一篇很长的文章，所以你可以随意跳到你感兴趣的部分:

1.  在创建解决方案之前，确定您有一个问题。
2.  为工作选择合适的工具。
3.  简单才是王道。
4.  你的函数、类和组件应该有一个明确的目的。
5.  命名很难，但很重要。
6.  不要重复代码。
7.  删除死代码，不要留下注释。
8.  常量值应该在静态常量或枚举中。
9.  比起定制解决方案，更喜欢内部功能。
10.  使用特定语言的指南。
11.  避免创建多个相互嵌套的代码块。
12.  不是最少几行的问题。
13.  学习设计模式以及何时不使用它们。
14.  将你的类分成数据持有者和数据操纵器。
15.  从根本上解决问题。
16.  抽象的隐藏陷阱。
17.  世界的规则不是你的应用程序的规则。
18.  如果可以的话，键入你的变量，即使你不需要这样做。
19.  编写测试。
20.  使用静态代码分析工具。
21.  人类代码审查。
22.  评论。
23.  文档。

# 1.在创建解决方案之前，确定您有一个问题。

无论你是在修复一个 bug，添加一个新功能还是设计一个应用程序，你本质上都是在为某人解决一个问题。理想情况下，您希望留下最少的问题。你应该清楚你用你的设计模式选择、重构、外部依赖、数据库和其他你花费宝贵时间的东西来解决什么问题。

你的代码是一个潜在的问题。即使是漂亮的那个。任何一段代码不再是问题的唯一时间是当一个项目完成并死亡时——不再被支持。为什么？因为有人必须在项目生命周期中阅读它，理解它，修正它，扩展它，甚至完全删除它所提供的特性。

维护代码库需要很多时间，而且没有多少程序员喜欢这样做，因为它缺乏创造性。编写更简单的代码，这样初级开发人员可以在需要时修复它，您可以自由处理更大的问题。

失去时间是个问题。您的任务可能有一个完美的解决方案，但有时对于开发人员来说可能很难看到。有些任务，最好的解决方案是让客户相信他想要的并不是他真正需要的。它需要对应用程序及其用途有更深入的理解。您的客户可能想要一个全新的模块，当他只需要对现有选项进行一些定制时，这个模块最终会变成数千行额外的代码。结果可能是，您只需要对现有的代码库做一点点修改，从而节省时间和金钱。

还有其他类型的问题。假设您需要实现一个可过滤的记录列表。您将数据保存在数据库中，但是不同记录之间的连接很复杂。在分析了客户希望如何过滤数据之后，您发现由于数据库设计的原因，您将不得不花费大约 20 个小时来构建包含多个连接和内部查询的复杂 SQL 查询。为什么不解释有一个不同的解决方案，需要 1 个小时，但会错过部分功能？结果可能是额外的功能不值得你花费这么多时间，这就转化为金钱成本。

# 2.为工作选择合适的工具。

这种闪亮的银弹语言，一个你无条件喜欢的框架或者一个新的数据库引擎，可能并不是解决你所面临问题的正确工具。在一个严肃的项目中，不要选择你刚刚听说的对所有事情都很棒的工具。这是导致灾难的原因。如果您的数据需要关系，仅仅为了学习而选择 MongoDB 将不会有好结果。您知道您可以做到这一点，但是通常您需要一种变通方法，这种方法会产生额外的代码来提供次优的解决方案。当然，你甚至可以用一块木板来敲钉子，但是快速的谷歌搜索可能会让你找到一把锤子。也许自从你上次检查以来，有一个人工智能可以自动为你做这件事。

# 3.简单才是王道。

你可能听说过这句话“[过早优化是万恶之源](http://wiki.c2.com/?PrematureOptimization)”。它持有部分真理。你应该更喜欢简单的解决方案，除非你确信它不会工作。不只是相信它不会工作，而是已经尝试过或预先计算过，并确信它不会工作。无论出于什么原因选择更复杂的解决方案，无论是执行速度、缺少 RAM、可扩展性、缺少依赖性还是其他原因，都会严重影响代码的可读性。不到万不得已，不要把事情复杂化。例外情况是，如果您知道一个更有效的解决方案，并且您知道它的实现不会影响可读性或您的时间要求。

同样，如果语言的所有新特性对你和你的团队没有好处，你也不需要使用它们。新并不意味着更好。如果你不确定，回到[第一点](https://alemil.com/guidelines-for-writing-readable-code#guide1)，在重构之前考虑你试图解决什么问题。仅仅因为 Javascript 有太多编写 for 循环语句的新方法，并不意味着如果需要索引变量，for 循环就会过时。

# 4.你的函数、类和组件应该有一个明确的目的。

你知道[固](https://en.wikipedia.org/wiki/SOLID)的原理吗？我发现这些对于设计通用库来说非常好，但是即使我使用过几次，也在工作项目中看到过一些实现，我认为这些规则有点太混乱和复杂了。

将你的代码分成几个函数，每个函数做一件事。例如，让我们考虑如何实现一个按钮。Button 可以是一个集合了按钮所有功能的类。你可以用一个在屏幕上绘制按钮的函数，另一个在鼠标经过时高亮显示按钮的函数，还有一个在点击按钮时调用的函数，还有一个在点击按钮时激活按钮的函数。你可以进一步分割它。如果你需要根据屏幕分辨率计算一个按钮的矩形位置，不要在 draw 函数中做。在不同的类中实现它，因为它可以被其他 GUI 元素使用，并且只在绘制按钮时使用它。

这是一件简单的事情，只要你认为“这不是必须的”，你就可以把它移到另一个函数中，通过用函数名和注释包装一段代码，为开发人员提供更多的信息。

考虑下面的例子，做同样的事情，哪一个通知它做得更快？

```
// C++ 
if (currentDistance < radius2) { 
    // This is sight of a player 
    if (!isLight) { 
        // If lighting of the tile is about 30% (so sight in darkness is worse) or distance from player is 1, tile should be visible. 
        if (hasInfravision || map.getLight(mapPosition) > 0.29f || ASEngine::vmath::distance(center, mapPosition) == 1) {
            map.toggleVisible(true, mapPosition); 
        } 
    } 
    // This is for light calculations 
    else { 
        ASEngine::ivec3 region = World::inst().map.currentPosition;
        ASEngine::ivec2 pos = mapPosition; 
        if (mapPosition.x > 63) { 
            pos.x -= 64; 
            region.x += 1; 
        } else if (mapPosition.x < 0) { 
            pos.x += 64; 
            region.x -= 1; 
        } if (mapPosition.y > 63) { 
            pos.y -= 64; 
            region.y += 1; 
        } else if (mapPosition.y < 0) { 
            pos.y += 64; 
            region.y -= 1; 
        }
        map.changeLight(pos, region, 1.0f - static_cast(currentDistance) / static_cast(radius2)); 
    }
}
```

```
// C++
**if** (currentDistance < radius2) {
    // This is sight of a player
    **if** (!isLight) {
        **this**->markVisibleTile(hasInfravision, map, center, mapPosition);
    }
    // This is for light calculations
    **else** {
        ASEngine::ivec3 region = World::inst().map.currentPosition;
        ASEngine::ivec2 pos = map.getRelativePosition(mapPosition, region);
        map.changeLight(pos, region, 1.0f - **static_cast**(currentDistance) / **static_cast**(radius2));
    }
}
```

# 5.命名很难，但很重要。

变量和函数的名字应该是不同的，并提供它们的作用的一般概念。关于命名的重要事情是它应该描述它对你的团队做了什么，所以它应该符合项目中选择的约定。即使你不同意他们。如果数据库中的每个记录请求都以“find”开头，比如“findUser”，那么如果您来到项目并将数据库函数命名为“getUserProfile ”,您的团队可能会感到困惑，因为这是您所习惯的。尽可能尝试分组命名，例如，如果您有许多用于输入验证的类，将“Validator”作为名称的后缀可以快速提供该类的用途信息。

根据标准选择并坚持案例类型。读骆驼案、蛇案、烤肉串案和啤酒真的很令人困惑🍻同一项目的不同文件中使用的案例。

# 6.不要重复代码。

我们已经确定代码是一个问题，那么为什么要重复你的问题来节省几分钟呢？真的没有意义。你可能会认为仅仅通过复制和粘贴就可以快速解决问题，但是如果你认为你必须复制超过 2 行的代码，试着接受你可能会错过一个更好的解决方案的想法。也许是一个通用函数，或者一个循环？

# 7.删除死代码，不要留下注释。

注释代码令人困惑。有人临时移除了吗？重要吗？什么时候评论的？它死了，让它脱离苦海。把它拿掉。我知道你对删除代码犹豫不决，因为事情可能会变糟，你想只是取消注释。你甚至可能非常依恋它，因为你花了时间和精力想出了它。或者你可能认为“很快”就会需要它。所有这些问题的解决方案是版本控制软件。如果需要的话，只需使用 [git history](https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History) 来检索代码。自己收拾干净！

# 8.常量值应该在静态常量或枚举中。

你用字符串还是整数来定义对象的类型？例如，用户可以拥有“管理员”或“访客”角色。您将如何检查用户是否拥有“管理员”角色？

```
if ($user->role == "admin") { 
    // user is admin
}
```

这不太好。首先，如果名称“admin”改变了，你必须在整个应用程序中改变它。你可能会说这种情况很少发生，现代的 ide 使得取代它并不困难。确实如此。另一个原因是缺少自动完成功能，因为拼写错误问题出现了。这些调试起来可能会很麻烦。

通过根据语言定义全局常量或枚举，您可以从自动完成中获益，并在需要时在一个地方更改值。您甚至不必记住常量背后隐藏着什么样的值，您只需让 IDE 自动完成功能提供神奇的帮助。

```
// PHP
**const** ROLE_ADMIN = "admin";

**if** ($user->role == ROLE_ADMIN) { 
    // user is admin
}
```

```
// C++
enum **class** **Role** { GUEST, ADMIN }; // It's possible to map these enums to strings, but it's not needed.

**if** (user.role == Role.ADMIN) { 
    // user is admin
}
```

不仅仅是你的对象的类型。在 PHP 中，你可以用字符串作为字段名来定义数组。对于复杂的结构，很难不打错字，因此最好使用对象来代替。尽量避免用字符串编码，你会从自动补全功能带来的打字错误减少和速度提高中获益。

# 9.比起定制解决方案，更喜欢内部功能。

如果您为项目选择的语言或框架为您提供了问题的解决方案，请使用它。每个人都可以快速谷歌一个功能是做什么的，即使不经常使用。可能需要更多时间来找出您的定制解决方案。如果你发现一段代码和一个内部函数做同样的事情，就快速重构，不要不管它。删除代码不再是一个问题，所以删除代码是伟大的！

# 10.使用特定语言的指南。

如果你用 PHP 写，你应该了解一下 [PSRs](https://www.php-fig.org/psr/) 。对于 Javascript，Airbnb 提供了一个不错的[指南。对于 C++来说，有来自谷歌的](https://github.com/airbnb/javascript)[指南](https://google.github.io/styleguide/cppguide.html)或来自 C++创始人比雅尼·斯特劳斯特鲁普的[核心指南](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md)。其他语言可能有他们自己的质量代码指南，或者你甚至可以为你的团队提出你自己的标准。重要的部分是[强制使用为项目选择的指南](https://alemil.com/guidelines-for-writing-readable-code#guide20)，因此对于如何开发它有一个统一的愿景。它防止了许多问题，这些问题来自不同的人，他们有自己独特的经历，做他们习惯做的事情。

# 11.避免创建多个相互嵌套的代码块。

只需比较这两个代码块:

```
**void** ProgressEffects::progressPoison(Entity entity, std::shared_ptr<Effects> effects)
 {
     **float** currentTime = DayNightCycle::inst().getCurrentTime();
     **if** (effects->lastPoisonTick > 0.0f && currentTime > effects->lastPoisonTick + 1.0f) {
         **if** (effects->poison.second > currentTime) {
             std::shared_ptr<Equipment> eq = nullptr;
             **int** poisonResitance = 0;
             **if** (**this**->manager.entityHasComponent(entity, ComponentType::EQUIPMENT)) {
                 eq = **this**->manager.getComponent<Equipment>(entity);
                 **for** (**size_t** i = 0; i < EQUIP_SLOT_NUM; i++) {
                     **if** (eq->wearing[i] != invalidEntity && **this**->manager.entityHasComponent(eq->wearing[i], ComponentType::ARMOR)) {
                         std::shared_ptr<Armor> armor = **this**->manager.getComponent<Armor>(eq->wearing[i]);
                         poisonResitance += armor->poison;
                     }
                 }
             }
             **int** damage = effects->poison.first - poisonResitance;
             **if** (damage < 1) damage = 1;
             std::shared_ptr<Health> health = **this**->manager.getComponent<Health>(entity);
             health->health -= damage;
         } **else** {
             effects->poison.second = -1.0f;
         }
     }
 }
```

```
**void** ProgressEffects::progressPoison(Entity entity, std::shared_ptr effects)
 {
     **float** currentTime = DayNightCycle::inst().getCurrentTime();
     **if** (effects->lastPoisonTick < 0.0f || currentTime < effects->lastPoisonTick + 1.0f) **return**;
     **if** (effects->poison.second <= currentTime) {
         effects->poison.second = -1.0f;
         **return**;
     }

     **int** poisonResitance = **this**->calculatePoisonResistance(entity);
     **int** damage = effects->poison.first - poisonResitance;
     **if** (damage < 1) damage = 1;
     std::shared_ptr health = **this**->manager.getComponent(entity);
     health->health -= damage;
 }
```

第二本书更容易阅读，不是吗？如果这样的解决方案是可行的，尽量避免嵌套 If 和循环块。一个常见的技巧是在移动到代码块之前反转 if 语句并从函数返回，就像上面的例子一样。

# 12.不是最少几行的问题。

我们常说，用较少的代码行来完成任务的一段代码更好。我们中的一些人甚至沉迷于我们添加或删除了多少行代码，用计数来衡量我们的生产率。我们这样做是为了简化，但如果不考虑可读性，这不是一个应该遵循的规则。您可以将所有内容都压缩在一行中，但是很可能要比将它分成几行，每行一个命令要难理解得多。

一些语言提供了编写简短 if 语句的可能性，比如:

```
$variable == $x ? $y : $z; // if ($variable == x) { $result = $y; } else { $result = $z; }
```

这可能是一个很好的选择，但也很容易做过头:

```
$variable == $x ? ($x == $y ? array_merge($x, $y, $z) : $x) : $y; // What is this heresy?!
```

拆分后应该更容易把握。

```
$result = $y;
**if** ($variable == $x && $x == $y) $result = array_merge($x, $y, $z);
**else** **if** ($variable == $x) $result = $x;
```

这 3 行在屏幕上占用了更多的空间，但是分析数据所花费的时间却更少。

# 13.学习设计模式以及何时不使用它们。

有许多不同的[设计模式](https://en.wikipedia.org/wiki/Software_design_pattern%22)经常被用来解决编码问题。您应该记住的是，尽管这些模式解决了应用程序中的特定问题，但它们的有用性会受到许多不同因素的影响，如项目的规模、参与项目的人数、时间(成本)约束或解决方案所需的复杂性。有些模式被命名为反模式，比如单例模式，因为即使它们提供了一些解决方案，在某些情况下也会引入问题。

在为您的特定解决方案选择设计模式之前，请确保您理解了在复杂性方面的实现成本。在一个简单的系统中，你可能不需要 Observer 模式来进行组件间的通信，也许几个布尔值就能产生一个简单的解决方案？花时间在更大、更复杂的应用程序中实现所选的设计模式更合理。

# 14.将你的类分成数据持有者和数据操纵器。

数据容器类是一个在其内部数据结构中保存一些数据的类。它允许根据需要通过 getters 和 setters 访问数据，但是不操纵数据，除非在将数据保存在系统中时总是改变数据，或者在访问时总是必须改变数据。

一个很好的例子是在[实体组件系统](https://alemil.com/entity-component-system)架构模式中，组件只保存数据，系统操纵和处理数据。另一个用例是为与外部数据库通信而实现的存储库设计模式，其中“模型”类以特定于语言的结构表示来自数据库的数据，而“存储库”类将数据与数据库同步，或者在模型上保存更改，或者获取更改。

这种分离使得理解应用程序的不同部分变得更加容易。考虑上面的存储库示例。如果您想要显示模型集合中的数据列表，您需要知道这些数据来自哪里吗？您需要知道它在数据库中是如何存储的，以及它需要如何映射到特定于语言的结构吗？这两个问题的答案都是否定的。您可以通过现有的存储库方法提取模型，并只关注您在任务中需要做的事情，即显示数据。

[实体组件系统](https://alemil.com/entity-component-system)例子怎么样？如果你需要实现一个系统来处理技能的使用，播放动画，声音，伤害等等。不需要知道技能是怎么触发的。如果人工智能脚本在某些条件下启动技能或者玩家使用热键来激活它，这并不重要。您唯一需要做的事情是识别组件中的数据被更改，这表明需要处理哪种能力。

# 15.从根本上解决问题。

您需要实现一个新特性，将其添加到现有的代码库中。当你进入需要修改的代码部分时，你遇到了一个问题。您的函数输入的结构不能很好地满足您的需要，因此您必须编写相当多的额外代码来重新组织数据，并在实现您的解决方案之前提取更多的数据。

在你这样做之前，试着在你的代码库中后退几步。这些数据从何而来，如何使用？也许你可以从外部获得一种更容易处理的格式，或者在你获得它时立即改变它？通过从根本上解决这个问题，您可能会在多个地方以及未来的功能或更改中解决相同的问题。总是试图简化您保存数据的方式，以便您一得到数据就可以轻松访问。当您从外部来源接收数据时，这一点尤其重要。如果您需要来自应用程序或外部 API 的用户的数据，您应该剔除不必要的东西，并立即重新组织其余的东西。

# 16.抽象的隐藏陷阱。

为什么我们要为我们的问题写通用的、抽象的解决方案？为了轻松地扩展我们的应用程序，使它更容易适应新的需求和重用我们的代码，这样我们就不必再编写它了。

就代码可读性而言，抽象通常会带来沉重的代价。抽象的最高层次是当所有的事情都为你解决了，而实现是隐藏的。您可以配置在给定输入的情况下如何处理您的数据，但您无法控制细节，例如，数据将如何存储在您的数据库中，处理数据的效率如何，记录了哪些信息等等。这种解决方案的论点是，如果一个新的数据源必须以与当前数据源相同的方式进行处理，那么很容易将它扔进库中，并指出它应该存储在哪里。你本质上是在用控制来换取实现的速度。

当出了问题，并且不是一个很好记录的问题时，有人将很难理解所有试图解决不必要问题的通用想法。如果我们负担得起，我们真的不应该想隐藏实现细节。保持对代码库的控制允许更大的灵活性。不要仅仅因为你认为它“可能”在将来被扩展，就为简单的问题写一个通用的解决方案。这种情况很少发生，需要时可以重写。

让我们考虑一个例子。如果您可以创建一个类，它可以从 CSV 文件中导入数据，并用 10-15 行可读代码将其打包到数据库中，那么为什么要创建两个类并推广解决方案，以便将来可以扩展到从 XLS 或 XML 导入数据，而您甚至不知道您的应用程序会需要这样做呢？为什么要拉一个你不需要的 5k 行代码的外部库来解决这个问题？

很少有必要概括数据的存储位置。在您的职业生涯中，您更换过几次数据库引擎？在过去的 10 年里，我遇到过一次以这种方式解决的问题。创建抽象解决方案是昂贵的，而且通常是不必要的，除非你正在创建一个必须同时满足大量不同项目的库。

相比之下，当你确定你必须允许从 XLS 和 CSV 开箱进口，那么一般的解决方案可能是一个完全可行的选择。如果您以后在应用程序的需求发生变化时编写一个通用的解决方案，这也没什么大不了的。当有人需要替换它时，有一个简单明了的解决方案会容易得多。

# 17.世界的规则不是你的应用程序的规则。

当在应用程序中实现 OOP 范例时，我有一个关于建模“真实世界”的有趣的争论。假设我们必须为一个广告系统处理大数据。我们有两种类型的日志消息。首先是关于广告发射的信息，其保存一些数据。第二个日志通知有人点击了广告，其中包含与 emission 完全相同的数据和一些额外的字段。排放日志没有点击不包含的数据。

在现实世界中，我们可能会认为查看和点击广告这两个动作是分开的，但却是相似的。因此，通过对现实世界建模，我们可以创建一个基本的“Log”类，并扩展为“ClickLog”和“EmissionLog”类，如下所示:

```
**struct** **Log** {
    **int** x;
    **int** y;
    **int** z;
}
**struct** **EmissionLog** : **public** Log {}
**struct** **ClickLog** : **public** Log {
    **float** q;
}
```

上面的例子说明了这个系统在现实世界中是如何很好地工作的。发出一个广告和有人点击它是完全不同的。然而，这样的选择并没有传达一个重要的信息。在我们的应用程序中，所有可以处理排放日志的东西都可以在点击时工作。我们可以使用相同的类来处理这两者，但是由于数据的差异，只有一些点击处理器不能处理排放。

在我们的应用程序中，与现实世界不同，我们的 ClickLog 是 EmissionLog 的扩展。可以用相同的方式处理它，使用操作排放日志的相同类。如果您从 emission 日志中扩展点击，那么您会告诉您的同事，emission 上可能发生的所有事情都可能发生在点击上，而他们不需要知道应用程序中所有可能的日志处理器。

```
**struct** **EmissionLog** {
    **int** x;
    **int** y;
    **int** z;
}
**struct** **ClickLog** : **public** EmissionLog {
    **float** q;
}
```

# 18.如果可以的话，输入你的变量，即使你没有必要。

如果你只使用静态类型的语言，你可以跳过这一步。在 PHP 或 Javascript 等动态类型语言中，如果不转储变量的内容，很难理解一段代码应该做什么。出于同样的原因，当单个变量可以是一个对象、一个数组或一个空值时(取决于某些条件),代码可能非常不可预测。在你的函数参数中允许尽可能少的变量类型。解决办法是有的。从版本 7 开始，PHP 可以有类型化的参数和返回类型，你可以选择 Typescript 而不是干净的 Javascript。它有助于代码的可读性，并防止愚蠢的错误。

如果没有必要，也不要允许空值。Null 是令人憎恶的。必须显式检查它是否存在，以避免需要不必要代码的致命错误。Javascript 中的事情更可怕，因为它是空的和未定义的。标记可以为空的变量，以便通知您的同事:

```
// PHP >= 7.1
**function** **get**(?int count): **array** { 
    //... 
}
```

```
// Typescript
**interface** **IUser** = {
    name?: **string**; // name field might not be available
    type: number;
}
```

# 19.编写测试。

随着时间的流逝，我们设法避免了精疲力尽，我们提高到了这样一个程度，我们可以在头脑中绘制甚至复杂的特性，并且在完全实现第一个草案之前，不需要检查代码是否工作，就可以实现它。在这一点上，用 [TDD 周期](https://alemil.com/test-driven-development)来写感觉有点浪费时间，因为在写之前检查每一件事会有点慢。编写集成测试来确保您的整个特性按要求工作是一个很好的实践，因为您可能会留下一些小错误，并且您可以在几毫秒内运行检查。

如果你对你的语言或库还没有经验，并且在寻找解决问题的方法时经常尝试不同的角度，你可以从[编写测试](https://alemil.com/test-driven-development)中受益匪浅。它鼓励把你的工作分成更容易管理的部分。集成测试解释了你的代码很快解决了什么样的问题，这可能比一般的实现更快地提供信息。一个简单的“这个输入期望这个输出”可以加快理解应用程序的过程。

# 20.使用静态代码分析工具。

有许多开源静态代码分析工具可用。先进的 ide 也提供了相当多的实时功能。它们有助于让你的项目走上正轨。在 docker 环境中，您可以在每次提交时自动运行存储库中的一些管道。

PHP 的可靠选择:

*   [复制/粘贴检测器](https://github.com/sebastianbergmann/phpcpd)
*   [PHP 混乱检测器](https://phpmd.org/) —检查潜在的错误和复杂性
*   PHP 代码嗅探器 —检查编码标准。
*   [PHPMetrics](https://github.com/phpmetrics/PhpMetrics) —带有仪表板和图表的静态分析工具。

Javascript:

*   [js hint](https://github.com/jshint/jshint)/[JsLint](https://github.com/douglascrockford/JSLint)—发现错误和潜在问题，可以与 IDE 集成进行实时分析。
*   [Plato](https://github.com/es-analysis/plato) —源代码可视化和复杂性工具。

C++:

*   [Cppcheck](http://cppcheck.sourceforge.net/) —检测错误和未定义的行为。
*   [OClint](https://github.com/oclint/oclint) —提高代码质量。

多语言支持:

*   pmd —烟雾探测器。

# 21.人类代码审查。

代码评审只是另一个程序员通过检查你的代码来发现错误并帮助提高软件质量。尽管它们可以帮助应用程序的整体质量，并允许团队中的知识流动，但只有当每个人都愿意接受建设性的批评时，它们才是有用的。有时候，进行评估的人想要强化他们的视野和经验，不接受不同的观点，这也很难接受。

根据团队环境的不同，这可能很难实现，但收获可能是难以置信的。我参与编码的最大最干净的应用程序是通过非常彻底的代码审查完成的。

# 22.评论。

您可能已经注意到，我喜欢保持简单的编码规则，这样团队中的每个人都可以很容易地遵循。评论也是一样。

我认为应该给每个函数添加注释，包括构造函数、每个类属性、每个静态常量和每个类。这是一个纪律问题。当你允许懒惰，允许在“有些事情不需要评论，因为它是不言自明的”时，你就会得到懒惰。

无论你在实现特性时在想什么(与工作相关！)是写在评论里的好东西。尤其是一切是如何工作的，一个类是如何使用的，这个枚举的目的是什么等等。目的非常重要，因为很难仅仅通过正确的命名来解释，除非有人事先已经知道了约定。

我理解“InjectorToken”对你来说完全有意义，你可能认为它“不言自明”。坦率地说，这是一个伟大的名字。但是当我看这个课程的时候，我想知道的是——这个令牌是做什么的，它是做什么的，我如何使用它，以及这个注射器是什么东西。如果能在评论中看到这一点就太好了，这样就没有人需要查看整个应用程序了，对吗？

# 23.文档。

我知道，我知道，我也讨厌写纪录片。如果你在评论中写下你所知道的一切，那么这一点可能会被一些工具自动生成。尽管如此，文档可以让您快速查找关于应用程序应该如何工作的重要信息。

您可以使用 [Doxygen](http://www.stack.nl/~dimitri/doxygen/index.html) 来自动生成文档。

# 结论

这篇文章之所以是一套指导方针而不是规则，是因为我相信有很多方法是正确的。如果你确信一切都应该被抽象化，那就开始吧。如果你相信坚实的原则将被用在每一个应用程序中，或者如果一个解决方案不是通过众所周知的设计模式完成的，那么它马上就是坏的，这很好。选择适合你和你的团队的道路，并坚持下去。如果你有一种实验的心情，试试我在这篇文章中提到的一些事情。希望它能提高你的工作质量。感谢阅读，如果你觉得有趣，不要忘记分享！

*最初发表于*[T5【alemil.com】](https://alemil.com/guidelines-for-writing-readable-code)*。*