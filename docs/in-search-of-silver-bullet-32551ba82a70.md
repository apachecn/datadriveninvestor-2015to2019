# 寻找银弹

> 原文：<https://medium.datadriveninvestor.com/in-search-of-silver-bullet-32551ba82a70?source=collection_archive---------35----------------------->

![](img/f8240f55191a4a567cf26485b2664ef3.png)

Photo by [Stanley Dai](https://unsplash.com/photos/73OZYNjVoNI?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/collections/3518190/my-first-collection/04e68a7fe7e7fc2075c3f966aab0a64e?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

当我还是一个年轻天真的初级开发人员时，我相信有一个写软件的银弹。不是我没读过那篇传奇的文章。然而，我希望在 CS 世界的某个地方有什么东西可以把我从代码库的混乱中拯救出来。

我以实习生的身份开始了我的职业生涯，然后是一个项目的初级开发人员，那个项目已经有五年的历史了。这很酷，持续了几年，但是我越深入各种子系统，我就越觉得那里有问题——存在太多的错误，太容易添加更多的错误。

首先，我认为问题在于缺乏测试。我继承并负责的子系统肯定没有足够的测试覆盖面(虽然我们可以争论多少才是“足够的”，但我非常确定每个重要的功能 1 次测试是远远不够的)。所以我开始编写单元测试。很多都是。这在一定程度上有所帮助。然而，很快我意识到，大多数情况下，您无法测试给定方法的每一种可能的输入组合，并且在生产中会不时出现极端情况。

所以，我想问题可能出在 OOP 设计上。在某种程度上，这种范式变得非常流行(好吧，我们都知道——现代开发人员中有谁没有读过“四人帮”的那本书，或者不能在半夜说出 OOP 的三个属性？)并且在任何地方都被用作默认解决方案。我钻研细节。我开始学习函数式编程，甚至是当地 FP 爱好者社区的活跃成员。

他们说，FP 防止你用错误编程。他们说，你需要的只是 FP。所以，我在 Haskell 上写了几个宠物项目，作为面向 FP 语言的典型例子，你知道吗？我确实设法编了一些程序错误！事实上，由于强大的静态类型系统，我避免了许多愚蠢的错误。然而，这个属性以及 purity 并不能保证期望排序的函数返回一个已排序的集合。

所以，我深入研究了一下。了解了依赖型，接触了 Agda。你在 Haskell 上编程过吗？如果是这样，想象一种更加严格和正式的语言——就像 Agda 一样。依赖类型是一个强大的工具，它允许在编译时检查给定函数是否做了预期的事情(例如，排序函数返回与作为输入提供的元素相同的元素的排序集合)。听起来像个奇迹，对吧？你不能在你的程序中遇到一个错误，因为如果它有一个，它甚至不会编译！是的，这里有一个严重的问题。编写这样的代码既困难又耗时。实际上，你写了一个规范(以函数类型签名的形式),并以非常详细的方式实现它。这种方法可能对科学目的有用，但在当今的商业中几乎不适用。可悲的是。还有，说到规格——谁说你写出来没有 bug？

在玩了 Agda 之后，我明白我不会找到比下面的事实更有用的东西了:

你知道的工具越多，你就越专业。

软件开发人员通常喜欢学习几种编程语言，并在适当的时候使用它们。这同样适用于编程范例:想象一下，你不仅有一把锤子，还有一把刀、一把锯和一把螺丝刀，因此对你来说，世界远比一堆钉子更加多样化。

基本上，每种语言都允许在每种范式中编写代码(比如，您可以使用单子在 Haskell 中强制性地编写代码——这个例子无疑被夸大了；像 Java 和 C++这样更流行的语言允许在范例之间无缝切换)。

那么，我对那些努力成为更好的软件开发人员的人有什么建议呢？找些时间练习一点 OOP，一部分 FP，接触好的旧程序代码，玩玩逻辑编程(只是为了好奇！).这些经历不会阻止你编写 bug，但至少你不会再到处看到钉子。