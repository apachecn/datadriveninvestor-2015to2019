# 调试提示:按值传递与按引用传递

> 原文：<https://medium.datadriveninvestor.com/debugging-tip-pass-by-value-vs-pass-by-reference-903781ebc202?source=collection_archive---------38----------------------->

![](img/8325ee765f83fc199b69c3aebb22dc4b.png)

Debugging all this code could get frustrating!

作为一名计算机科学导师，同时也是一名开发人员，我经常会遇到一些有趣而令人沮丧的错误。幸运的是，我可以把自己算作一个相当不错的调试器，但有时我会遇到一些真正令人挠头的问题，需要一些坚持。

我在新生中经常看到的一个问题与“按值传递”和“按引用传递”的概念有关。不管出于什么原因，我注意到我的许多编程入门学生，甚至在 AP 计算机科学课上，似乎都没有很好地理解这一思想，但是如果你没有意识到这一点，它可能会导致一些非常棘手的错误。

基本思想是，当您向函数或方法传递参数时，您要么发送参数值的副本(通过值传递)，要么发送参数在内存中的实际地址，这意味着在函数中对参数所做的任何更改都将覆盖内存中的值。换句话说，在第二种情况下，你是通过引用传递的。

从这个现实世界的例子来看。想象一下，你正在参加学校或工作的团队会议，你的团队正在做一份报告。你今天的任务是编辑你写好的文件，并完成最后的修改。您通常会选择这些方法中的哪一种？

A.给每个人带一份文档的副本，让每个人在自己的副本上写下他们的评论，然后将他们全部传回给你，以处理他们提供的信息。

B.把原始文件拿来，传来传去，这样每个人都可以在上面写下他们的意见。

如果我们把这个过程比作一个软件程序，我们可以说你的编辑团队的过程就像你在程序中调用的方法，而文档就是你传递的参数。

如果您选择了 A，那么您会理解在编辑会话之后，您的原始副本仍然是相同的。团队所做的任何工作都在副本上，你可以用这些副本做任何你认为必要的事情。您可能决定将他们的更改合并到您的原始文档中，从而替换它，或者您可以选择保持原样，但您的原始文档实际上并没有更改。这种方法类似于编程中的按值传递。在这种情况下，参数是原始文档的副本。

如果您选择了选项 B，一旦编辑过程(我们的函数)完成，您就直接对原始文档(我们的参数)进行了更改。所以论点实际上已经改变了，一旦我们回到函数调用方，也就是你，在这个例子中。这相当于在程序中通过引用传递。

那么为什么这会导致偷偷摸摸的 bug 呢？好吧，让我们考虑一个游戏，也许是国际象棋，它使用了人工智能。这将是一个不完美的例子，但我希望它是高水平的，所以你得到了基本的想法。如果我们和计算机比赛，我们的对手需要考虑所有不同的可能走法，并预测每种走法的结果，以便选择最佳的下一步行动。假设可能的移动存储在一个数组或列表中，我们有一个函数，它一次遍历并评估一个移动，从顶部删除下一个移动，然后根据上一个移动的结果添加新的可能移动。函数自变量是可能移动的初始列表。我们还会说，这个函数会保存一个单独的列表，列出每一个最佳可能的移动，这就是函数结束时返回的内容。听起来很合理，对吧？

如果我们使用的编程语言通过值传递初始移动列表，这可能是合理的。在这种情况下，游戏可以在函数中更改移动列表，并提出下一步移动，但不改变游戏棋盘的实际状态。一旦函数执行完毕，原始的移动列表并没有被修改，我们只是把它扔掉，然后我们回到调用函数的原始移动列表中。

但是，如果移动列表是通过引用传递的，那么一旦函数完成并返回，在函数中对它所做的任何更改实际上都将更改移动列表。这就像我们的编辑示例一样，我们没有将可能的编辑留在单独的纸上，我们的原始副本仍然是干净的，我们有其他人在我们的主副本上集思广益的结果，但我们已经丢失了原始内容。对于我们的移动列表来说，这是相同的想法。

当我们有一个列表，并且要从中删除元素时，这种情况会变得非常棘手。因为想象一下，如果你给一个函数发送一个列表，假设它在函数完成后保持一定的大小。然后你试图在列表上做一些额外的工作，只是发现现在列表变小了，甚至是空的，现在你得到了一个索引或空指针错误，因为你试图访问一个不再存在的列表元素。我在我和学生一起调试的一些程序中见过这种情况，这真的很难弄清楚，因为我们在整个程序中没有查看列表内容，所以我们不知道发生了什么，我们似乎无法做出任何预测或找到错误发生时的模式。直到我开始打印出所有可能与这个 bug 有关的变量和数据，我才意识到这个列表在缩小，为什么。

所以，这里的教训是要确保你知道你的编程语言关于参数何时通过值或引用传递的特定规则。如果你不确定，你可以看看文档或者快速谷歌搜索，甚至在论坛上问一下。我想说，把这个教训作为一种预防措施，省得以后再去追踪一个奇怪的错误。

# 有关系的

被打上标签的[编码](http://cloudyheavengames.com/tag/coding/)、[计算机科学](http://cloudyheavengames.com/tag/computer-science/)、[调试](http://cloudyheavengames.com/tag/debugging/)、[编程](http://cloudyheavengames.com/tag/programming/)。将[永久链接](http://cloudyheavengames.com/debugging-tip-pass-value-vs-pass-reference/)加入书签。

*原载于 2018 年 9 月 17 日*[*cloudyheavengames.com*](http://cloudyheavengames.com/debugging-tip-pass-value-vs-pass-reference)*。*